---
AWSTemplateFormatVersion: '2010-09-09'
Description: Main CF template that builds shared resources and other stacks
Parameters:
  DatabaseName:
    Type:  String
    Description: Name of the Athena database to hold lambada information
    Default: optimization_data
  DestinationBucket:
    Type: String
    Description: Name of the S3 Bucket that is created to hold tgw data
    AllowedPattern: (?=^.{3,63}$)(?!^(\d+\.)+\d+$)(^(([a-z0-9]|[a-z0-9][a-z0-9\-]*[a-z0-9])\.)*([a-z0-9]|[a-z0-9][a-z0-9\-]*[a-z0-9])$)
  DestinationBucketARN:
    Type: String
    Description: ARN of the S3 Bucket that exists or needs to be created to hold rightsizing information
  MultiAccountRoleName:
    Type: String
    Description: Name of the IAM role deployed in all accounts which can retrieve AWS Data.
  CFDataName:
    Type: String
    Description: The name of what this cf is doing.
    Default: transit-gateway
  GlueRoleARN:
    Type: String
    Description: ARN of the IAM role deployed to use for glue.
  Schedule:
    Type: String
    Description: Cloud watch event Schedule to trigger the lambda 
    Default: "rate(14 days)"
  RolePrefix:
    Type: String
    Description: This prefix will be placed in front of all roles created. Note you may wish to add a dash at the end to make more readable
  LambdaAnalyticsARN:
    Type: String
    Description: Arn of lambda for Analytics
  AccountCollectorLambdaARN:
    Type: String
    Description: Arn of the lambda for the Accounts Collector function
  CURTable:
    Type: String
    Description: The name of your Cost and Usage Report table in Athena
    Default: cid_cur.cur

Outputs:
  LambdaRoleARN:
    Description: Role for Lambda execution of collection data.
    Value: !GetAtt LambdaRole.Arn
  LambdaFunctionARN:
    Description: ARN for the module's primary Lambda function
    Value: !GetAtt LambdaFunction.Arn

Resources:
  LambdaRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub "${RolePrefix}Lambda-Role-${CFDataName}"
      AssumeRolePolicyDocument:
        Statement:
          - Action:
              - sts:AssumeRole
            Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
        Version: 2012-10-17
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Path: /
      Policies:
        - PolicyName: !Sub "Assume-Management-${CFDataName}-Account-Role"
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: "Allow"
                Action: "sts:AssumeRole"
                Resource: !Sub "arn:aws:iam::*:role/${MultiAccountRoleName}" # Need to assume a Read role in all Accounts
        - PolicyName: "LambdaTWGPolicy"
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: "Allow"
                Action:
                  - "s3:PutObject"
                Resource: 
                  - !Ref DestinationBucketARN
                  - !Sub "${DestinationBucketARN}/*"
              - Effect: "Allow"
                Action:
                  - "cloudwatch:GetMetricData"
                Resource: "*"
              - Effect: "Allow"
                Action:
                  - "ec2:DescribeRegions"
                Resource: "*"

  LambdaFunction:
    Type: AWS::Lambda::Function
    Properties:
      Architectures: [arm64]
      FunctionName: !Sub '${RolePrefix}${CFDataName}-Lambda-Collect'
      Description: LambdaFunction of python3.9.
      Runtime: python3.9
      Code:
        ZipFile: |
            import os
            import json
            import logging
            from datetime import date, timedelta, datetime

            import boto3
            from botocore.client import Config
            from botocore.exceptions import ClientError

            bucket = os.environ['BUCKET_NAME']

            logger = logging.getLogger()
            if "LOG_LEVEL" in os.environ:
                numeric_level = getattr(logging, os.environ['LOG_LEVEL'].upper(), None)
                if not isinstance(numeric_level, int):
                    raise ValueError('Invalid log level: %s' % loglevel)
                logger.setLevel(level=numeric_level)
            else:
                logger.setLevel(logging.INFO)

            last_day_of_prev_month = date.today().replace(day=1) - timedelta(days=1)
            start_day_of_prev_month = date.today().replace(day=1) - timedelta(days=last_day_of_prev_month.day)

            s3_client = boto3.client('s3')
            today = date.today()
            year = today.year
            month = today.month

            def lambda_handler(event, context):
                collection_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                if 'account' not in event:
                    raise ValueError(
                        "Please do not trigger this Lambda manually."
                        "Find the corresponding state machine in Step Functions and Trigger from there."
                    )

                try:
                    account = json.loads(event["account"])
                    account_id = account["account_id"]
                    account_name = account["account_name"]
                    payer_id = account["payer_id"]
                    logger.info(f"Collecting data for account: {account_id}")
                    regions = get_supported_regions() #FIXME: use intersection with ec2 regions
                    for region in regions:
                        logger.info(region_name)
                        try:
                            cw_client = assume_role('cloudwatch', account_id, region)
                            ec2_client = assume_role('ec2', account_id, region)
                            tgw_attachment_results = []
                            final_result = []
                            list_tgw_attachments = ec2_client.describe_transit_gateway_attachments()
                            for item in list_tgw_attachments['TransitGatewayAttachments']:
                                tgw_attachment_results.append(item)

                            cw_result = []
                            for item in tgw_attachment_results:
                                response_in = metrics(cw_client, 'BytesIn', item)

                                with open("/tmp/data.json", "w") as f:
                                    for cwitem in response_in['MetricDataResults']:
                                        cw_results = {
                                            'TGW': item['TransitGatewayId'],
                                            'NetworkingAccount': item['TransitGatewayOwnerId'],
                                            'CustomerAccount': item['ResourceOwnerId'],
                                            'TGW-Attachment': item['TransitGatewayAttachmentId'],
                                            'BytesIn': cwitem['Values'],
                                            'Region': region
                                        }

                                    response_out = metrics(cw_client, 'BytesOut', item)

                                    for cwitemout in response_out['MetricDataResults']:
                                        cw_results['BytesOut']= cwitemout['Values']
                                        logger.info (cw_results)
                                        jsondata = json.dumps(cw_results)
                                        f.write(jsondata)
                                        f.write('\n')

                                boto3.client("s3").upload_file(
                                    "/tmp/data.json",
                                    bucket,
                                    f"{os.environ['PREFIX']}/{os.environ['PREFIX']}-data/payer_id={payer_id}/year={year}/month={month}/tgw-{item['TransitGatewayAttachmentId']}-{region_name['RegionName']}.json"
                                )

                        except Exception as e:
                            logger.warning("%s" % e)
                    logger.info("Done")
                except Exception as e:
                    logger.warning(e)

            def metrics(cw_client, byte, item):
                cw_data = cw_client.get_metric_data(
                    MetricDataQueries=[
                        {
                            'Id': 'tgwMetric',
                            'MetricStat': {
                                'Metric': {
                                    'Namespace': 'AWS/TransitGateway',
                                    'MetricName': f'{byte}',
                                    'Dimensions': [
                                        {
                                            'Name': 'TransitGatewayAttachment',
                                            'Value': item['TransitGatewayAttachmentId']
                                        },
                                        {
                                            'Name': 'TransitGateway',
                                            'Value': item['TransitGatewayId']
                                        },
                                    ]
                                },
                                'Period': 2592000,
                                'Stat': 'Sum',
                            },
                            'ReturnData': True},
                    ],
                    StartTime=start_day_of_prev_month.strftime("%Y-%m-%dT%H:%M:%SZ"),
                    EndTime=last_day_of_prev_month.strftime("%Y-%m-%dT%H:%M:%SZ"),
                    ScanBy='TimestampDescending'
                )
                return cw_data

            def assume_role(service, account_id, region_name):
                role_name = os.environ['ROLENAME']
                role_arn = f"arn:aws:iam::{account_id}:role/{role_name}"
                cred = boto3.client('sts').assume_role(
                    RoleArn=role_arn,
                    RoleSessionName="data_collection"
                )['Credentials']
                return boto3.client(
                    service,
                    region_name=region_name,
                    aws_access_key_id=cred['AccessKeyId'],
                    aws_secret_access_key=cred['SecretAccessKey'],
                    aws_session_token=cred['SessionToken']
                )

            def get_supported_regions():
                return [region['RegionName'] for region in boto3.client('ec2').describe_regions()['Regions']]

      Handler: 'index.lambda_handler'
      MemorySize: 2688
      Timeout: 300
      Role: !GetAtt LambdaRole.Arn
      Environment:
        Variables:
          BUCKET_NAME: !Ref DestinationBucket
          PREFIX: !Ref CFDataName
          ROLENAME: !Ref MultiAccountRoleName

  AthenaQueryCUR:
    Type: AWS::Athena::NamedQuery
    Properties:
      Database: !Ref DatabaseName
      Description: Provides a chargeback view of the transit gateway
      Name: transit_gateway_chargeback_cur
      QueryString: !Sub
        CREATE OR REPLACE VIEW "transit_gateway_chargeback" AS
        WITH
          cur_all AS (
          SELECT *
          FROM
          ${DatabaseName}.transit_gateway_data
        )
        , customer_tgw_data AS (
          SELECT
            bill_billing_period_start_date
          , bill_payer_account_id
          , bill_billing_entity
          , line_item_usage_start_date
          , line_item_usage_account_id
          , line_item_line_item_type
          , line_item_product_code
          , line_item_usage_type
          , line_item_operation
          , line_item_line_item_description
          , product_product_name
          , product_operation
          , product_product_family
          , product_servicecode
          , product_servicename
          , product_location
          , year
          , month
          , sum(CAST(line_item_usage_amount AS decimal(16,8))) as usage_amount
          , CAST((sum(line_item_usage_amount) / sum(sum(line_item_usage_amount)) OVER (PARTITION BY product_location)) AS decimal(5,2)) as percentage
          FROM
            ${CURTable}
          WHERE line_item_usage_account_id <> '${AWS::AccountId}'
          AND product_location LIKE '%US%'
          AND product_group = 'AWSTransitGateway'
          AND pricing_unit = 'GigaBytes'
          GROUP BY 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18
        )
        , network_all AS (
          SELECT
            bill_payer_account_id
          , bill_billing_period_start_date
          , CAST(sum(CASE WHEN (line_item_line_item_type = 'EdpDiscount') THEN line_item_unblended_cost ELSE 0 END) AS decimal(5,2)) as EDP_Discounts
          , CAST(sum(CASE WHEN (product_group = 'AWSTransitGateway') THEN line_item_unblended_cost ELSE 0 END) AS decimal(5,2)) as Total_Cost
          FROM
            ${CURTable}
          WHERE
          line_item_line_item_type <> 'Tax'
          AND line_item_usage_account_id = '${AWS::AccountId}'
          AND line_item_product_code = 'AmazonVPC'
          AND (line_item_operation = 'CreateVpnConnection'
          OR line_item_operation = 'TransitGatewayVPC' 
          OR line_item_operation = 'TransitGatewayVPN'
          OR line_item_operation = 'TransitGatewayPeering')
          GROUP BY 1, 2
        )
        SELECT
          customer_tgw_data.bill_billing_period_start_date
        , customer_tgw_data.bill_payer_account_id
        , bill_billing_entity
        , line_item_usage_start_date
        , line_item_usage_account_id
        , line_item_line_item_type
        , line_item_product_code
        , line_item_usage_type
        , line_item_operation
        , line_item_line_item_description
        , product_product_name
        , product_operation
        , product_product_family
        , product_servicecode
        , product_servicename
        , Percentage as chargeback_proportion
        , Total_Cost as total_Networking_cost
        , (Total_Cost * Percentage) as chargeback_cost
        , Year
        , Month
        FROM
          customer_tgw_data
        LEFT JOIN network_all ON
          customer_tgw_data.bill_billing_period_start_date = network_all.bill_billing_period_start_date
          AND network_all.bill_payer_account_id = customer_tgw_data.bill_payer_account_id
        ORDER BY Percentage DESC

  AthenaQueryCW:
    Type: AWS::Athena::NamedQuery
    Properties:
      Database: !Ref DatabaseName
      Description: Provides a chargeback view of joined data from cloudwath and transigateway 
      Name: transit_gateway_chargeback_cw
      QueryString: !Sub
        CREATE OR REPLACE VIEW "transit_gateway_chargeback_to_customer_final_results" AS 
        WITH
          summary AS (
            SELECT
              *
            , (sum(bytesin[1]) + sum(bytesout[1]) OVER (PARTITION BY "bill_payer_account_id")) as total_data_transfer
            , (sum(bytesin[1]) + sum(bytesout[1])) as usage_account_dx_total
            FROM
              ${DatabaseName}.transit_gateway_data a
            LEFT JOIN ${DatabaseName}.transit_gateway_chargeback b ON a.customeraccount = b.line_item_usage_account_id AND a.year = b.year AND a.month = b.month
            GROUP BY 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29
            ORDER BY bytesIn DESC
          )
          SELECT
            *
          , (usage_account_dx_total / total_data_transfer) as chargeback_percentage
          , ("total_Networking_cost" * (usage_account_dx_total / total_data_transfer)) as chargeback_cost_final
          FROM
            summary

  Crawler:
    Type: AWS::Glue::Crawler
    Properties:
      Name: !Sub '${RolePrefix}${CFDataName}-Crawler'
      Role: !Ref GlueRoleARN
      DatabaseName: !Ref DatabaseName
      Targets:
        S3Targets:
          - Path: !Sub "s3://${DestinationBucket}/${CFDataName}/${CFDataName}-data/"

  StepFunctionExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      Path: /
      RoleName: !Sub "${RolePrefix}StepFunction-Role-${CFDataName}"
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - states.amazonaws.com
            Action:
              - sts:AssumeRole
      Policies:
        - PolicyName: "ModuleLambdaGlueExecutionPolicy"
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - glue:StartCrawler
                Resource: !Sub 'arn:aws:glue:${AWS::Region}:${AWS::AccountId}:crawler/${RolePrefix}${CFDataName}-Crawler'
              - Effect: Allow
                Action:
                  - lambda:InvokeFunction
                Resource:
                  - !Ref AccountCollectorLambdaARN
                  - !Sub
                    - '${Lambda}'
                    - Lambda: !GetAtt LambdaFunction.Arn

  StepFunction:
    Type: AWS::StepFunctions::StateMachine
    Properties:
      StateMachineName: !Sub '${RolePrefix}${CFDataName}-StateMachine'
      StateMachineType: STANDARD
      RoleArn: !GetAtt StepFunctionExecutionRole.Arn
      DefinitionString: |-
        {
          "Comment": "This state machine orchestrates the collection of AWS ${CFDataName} data and invokes the Glue Crawler to update Athena",
          "StartAt": "Account Collector Invoke",
          "States": {
            "Account Collector Invoke": {
              "Type": "Task",
              "Resource": "arn:aws:states:::lambda:invoke",
              "OutputPath": "$.Payload",
              "Parameters": {
                "Payload.$": "$",
                "FunctionName": "${AccountCollectorLambdaARN}"
              },
              "Retry": [
                {
                  "ErrorEquals": [
                    "Lambda.ServiceException",
                    "Lambda.AWSLambdaException",
                    "Lambda.SdkClientException",
                    "Lambda.TooManyRequestsException"
                  ],
                  "IntervalSeconds": 2,
                  "MaxAttempts": 6,
                  "BackoffRate": 2
                }
              ],
              "Next": "Module Map"
            },
            "Module Map": {
              "Type": "Map",
              "ItemProcessor": {
                "ProcessorConfig": {
                  "Mode": "INLINE"
                },
                "StartAt": "Module Invoke",
                "States": {
                  "Module Invoke": {
                    "Type": "Task",
                    "Resource": "arn:aws:states:::lambda:invoke",
                    "OutputPath": "$.Payload",
                    "Parameters": {
                      "FunctionName": "${LambdaFunction}",
                      "Payload": {
                        "account.$": "$.account"
                      }
                    },
                    "Retry": [
                      {
                        "ErrorEquals": [
                          "Lambda.ServiceException",
                          "Lambda.AWSLambdaException",
                          "Lambda.SdkClientException",
                          "Lambda.TooManyRequestsException"
                        ],
                        "IntervalSeconds": 2,
                        "MaxAttempts": 6,
                        "BackoffRate": 2
                      }
                    ],
                    "End": true
                  }
                }
              },
              "ItemsPath": "$.accountList",
              "Next": "Start Crawler"
            },
            "Start Crawler": {
              "Type": "Task",
              "Parameters": {
                "Name": "${Crawler}"
              },
              "Resource": "arn:aws:states:::aws-sdk:glue:startCrawler",
              "End": true
            }
          },
          "TimeoutSeconds": 1200
        }
      DefinitionSubstitutions: 
        CFDataName: !Ref CFDataName
        AccountCollectorLambdaARN: !Ref AccountCollectorLambdaARN
        LambdaFunction: !GetAtt LambdaFunction.Arn
        Crawler: !Sub '${RolePrefix}${CFDataName}-Crawler'

  ScheduleExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      Path: /
      RoleName: !Sub "${RolePrefix}EventBridge-Scheduler-Role-${CFDataName}"
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - events.amazonaws.com
            Action:
              - sts:AssumeRole
      Policies:
        - PolicyName: "ExecuteStateMachinePolicy"
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - states:StartExecution
                Resource: 
                  - !GetAtt StepFunction.Arn

  ModuleRefreshScheduleRule:
    Type: 'AWS::Events::Rule'
    Properties:
      Description: !Sub "Scheduler-For-${CFDataName}"
      Name: !Sub '${CFDataName}-ModuleRefreshRule'
      ScheduleExpression: !Ref Schedule
      State: ENABLED
      Targets:
        - Id: !Sub '${CFDataName}-ModuleRefresh'
          Arn: !GetAtt StepFunction.Arn
          RoleArn: !GetAtt ScheduleExecutionRole.Arn

  LambdaAnalyticsExecutor:
    Type: Custom::LambdaAnalyticsExecutor
    Properties:
      ServiceToken: !Ref LambdaAnalyticsARN
      Name: !Ref CFDataName