AWSTemplateFormatVersion: '2010-09-09'
Description: Organization data collections.
Parameters:
  ManagementRoleName:
    Type: String
    Description: The name of the IAM role that will be deployed in the management account which can retrieve AWS Organization data. KEEP THE SAME AS WHAT IS DEPLOYED INTO MANAGEMENT ACCOUNT
  ManagementAccountID:
    Type: String
    AllowedPattern: ([a-z0-9\-, ]*?$)
    Description: "(Ex: 123456789,098654321,789054312) List of Payer IDs you wish to collect data for. Can just be one Accounts"
  ResourcePrefix:
    Type: String
    Description: This prefix will be placed in front of all roles created. Note you may wish to add a dash at the end to make more readable
Outputs:
  LambdaFunctionName:
    Value: !Ref LambdaFunction
  LambdaFunctionARN:
    Description: Lambda function ARN
    Value: !GetAtt LambdaFunction.Arn
    Export:
      Name: !Sub ${ResourcePrefix}AccountCollectorLambdaARN
Resources:
  LambdaRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub "${ResourcePrefix}account-collector-LambdaRole"
      AssumeRolePolicyDocument:
        Statement:
          - Action:
              - sts:AssumeRole
            Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
        Version: 2012-10-17
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Path: /
      Policies:
        - PolicyName: "AssumeManagementRole"
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: "Allow"
                Action: "sts:AssumeRole"
                Resource: !Sub "arn:aws:iam::*:role/${ManagementRoleName}" # Need to assume a Read role in all Management Accounts
        - PolicyName: "CloudWatch"
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: "Allow"
                Action:
                  - "logs:CreateLogGroup"
                  - "logs:CreateLogStream"
                  - "logs:PutLogEvents"
                  - "logs:DescribeLogStreams"
                Resource: !Sub "arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/*"
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W28 # Resource found with an explicit name, this disallows updates that require replacement of this resource
            reason: "Need explicit name to identify role actions"

  LambdaFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub '${ResourcePrefix}account-collector-Lambda'
      Description: "Lambda function to retrieve the account list"
      Runtime: python3.10
      Architectures: [x86_64]
      Code:
          ZipFile: |
            import os
            import json
            import logging
            import boto3
            from botocore.exceptions import BotoCoreError
            from botocore.exceptions import ClientError

            ROLE_NAME = os.environ['ROLENAME']
            MANAGEMENT_ACCOUNT_IDS = os.environ['MANAGEMENT_ACCOUNT_IDS']
            MODULE_NAME = "account-collector"
            REGIONS = ["us-east-1"]

            logger = logging.getLogger(__name__)
            logger.setLevel(getattr(logging, os.environ.get('LOG_LEVEL', 'INFO').upper(), logging.INFO))

            # Helper Exception classes
            class CidError(Exception):
                def __init__(self, message="", exc=None):
                    message = f"({type(exc).__name__}) exception. {message}" if exc else message
                    if type(self) == CidNonCriticalError.__class__:
                        logger.warning(message)
                    else:
                        logger.error(message)
                    super().__init__(message)
            class CidNonCriticalError(CidError):
                def __init__(self, message="", exc=None):
                    super().__init__(message, exc)
            class CidCriticalError(CidError):
                def __init__(self, message="", exc=None):
                    super().__init__(message, exc)
            class ClientAccessError(Exception):
                def __init__(self, exc, role_name, account_id, service, region):
                    message = f"({type(exc).__name__}) exception: '{exc}' when getting '{service}' client with role '{role_name}' from account '{account_id}' in region '{region}'"
                    logger.warning(message)
                    super().__init__(message)

            def lambda_handler(event, context):
                logger.info(f"Incoming event: {event}")
                key = "Type"
                try:
                    accounts = main(event[key], MANAGEMENT_ACCOUNT_IDS, ROLE_NAME)

                except KeyError as exc:
                    raise CidCriticalError(f"(MissingParameterError) Lambda event missing '{key}' parameter in {MODULE_NAME} module", exc)
                except CidNonCriticalError as exc:
                    pass
                except CidCriticalError as exc:
                    raise exc
                except Exception as exc:
                    raise CidCriticalError(f"(UnhandledExceptionError) in {MODULE_NAME} module", exc)

                return {
                    'statusCode': 200,
                    'accountList': accounts
                }

            def main(module_type, management_accounts, role_name):
                logger.info(f"Processing for type '{module_type}' and using role '{role_name}'")
                account_list = []
                for payer_id in [r.strip() for r in management_accounts.split(',')]:
                    if (module_type.upper()) == 'LINKED':
                        try:
                            for account in iterate_accounts(role_name, payer_id):
                                if account['Status'] != 'ACTIVE':
                                    logger.info(f"Account {account['Id']} is not active")
                                    continue
                                account_data = {'account_id': account.get('Id'), 'account_name': account.get('Name'), 'payer_id': payer_id, }
                                account_list.append({"account" : json.dumps(account_data)})
                        except CidNonCriticalError as exc:
                            pass #Not necessarily fatal
                    else:
                        client = get_client_with_role(role_name, payer_id, region=REGIONS[0], service="organizations")
                        account = client.describe_account(AccountId=payer_id)['Account']
                        account_data = populate_account(payer_id, account['Name'], payer_id)
                        account_list.append({"account" : json.dumps(account_data)})

                if len(account_list) == 0:
                    raise CidCriticalError("No accounts were collected")

                logger.info(f"Successfully found {len(account_list)} accounts")
                logger.debug(f"Successfully found accounts: {json.dumps(account_list)}")
                return account_list

            def iterate_accounts(role_name, payer_id):
                logger.info(f"Iterating accounts for payer '{payer_id}'")
                try:
                    client = get_client_with_role(role_name, payer_id, region=REGIONS[0], service="organizations") #This MUST be us-east-1 regardless of lambda region
                    for page in client.get_paginator("list_accounts").paginate():
                        for account in page['Accounts']:
                            yield account

                except ClientAccessError as exc:
                    raise CidNonCriticalError(f"Payer account '{payer_id}' encountered access issues when iterating accounts", exc)


            def populate_account(account_id, account_name, payer_id):
                return { 'account_id': account_id, 'account_name': account_name, 'payer_id': payer_id, }

            def get_client_with_role(role_name, account_id, service, region):
                logger.debug(f"Getting '{service}' client with role '{role_name}' from account '{account_id}' in region '{region}'")
                try:
                    credentials = boto3.client('sts', region_name=region).assume_role(
                        RoleArn=f"arn:aws:iam::{account_id}:role/{role_name}",
                        RoleSessionName="data_collection"
                    )['Credentials']
                    logger.debug("Successfully assumed role, now getting client")
                    client = boto3.client(
                        service,
                        region_name = region,
                        aws_access_key_id=credentials['AccessKeyId'],
                        aws_secret_access_key=credentials['SecretAccessKey'],
                        aws_session_token=credentials['SessionToken'],
                    )
                    logger.debug("Successfully got client with assumed role")
                    return client

                except Exception as exc:
                    raise ClientAccessError(exc, role_name, account_id, service, region)
      Handler: 'index.lambda_handler'
      MemorySize: 2688
      Timeout: 600
      Role: !GetAtt LambdaRole.Arn
      Environment:
        Variables:
          ROLENAME: !Ref ManagementRoleName
          MANAGEMENT_ACCOUNT_IDS: !Ref ManagementAccountID
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W89 # Lambda functions should be deployed inside a VPC
            reason: "No need for VPC in this case"
          - id: W92 #  Lambda functions should define ReservedConcurrentExecutions to reserve simultaneous executions
            reason: "No need for simultaneous execution"