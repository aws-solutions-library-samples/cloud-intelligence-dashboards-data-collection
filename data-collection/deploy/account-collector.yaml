AWSTemplateFormatVersion: '2010-09-09'
Description: Organization data collections.
Parameters:
  ManagementRoleName:
    Type: String
    Description: The name of the IAM role that will be deployed in the management account which can retrieve AWS Organization data. KEEP THE SAME AS WHAT IS DEPLOYED INTO MANAGEMENT ACCOUNT
  ManagementAccountID:
    Type: String
    AllowedPattern: ([a-z0-9\-, ]*?$)
    Description: "(Ex: 123456789,098654321,789054312) List of Payer IDs you wish to collect data for. Can just be one Accounts"
  RolePrefix:
    Type: String
    Description: This prefix will be placed in front of all roles created. Note you may wish to add a dash at the end to make more readable
Outputs:
  LambdaFunctionName:
    Value: !Ref LambdaFunction
  LambdaFunctionARN:
    Description: Lambda function ARN
    Value: !GetAtt LambdaFunction.Arn
    Export:
      Name: AccountCollectorLambdaARN
Resources:
  LambdaRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub "${RolePrefix}account-collector-LambdaRole"
      AssumeRolePolicyDocument:
        Statement:
          - Action:
              - sts:AssumeRole
            Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
        Version: 2012-10-17
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Path: /
      Policies:
        - PolicyName: "AssumeManagementRole"
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: "Allow"
                Action: "sts:AssumeRole"
                Resource: !Sub "arn:aws:iam::*:role/${ManagementRoleName}" # Need to assume a Read role in all Management Accounts
        - PolicyName: "CloudWatch"
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: "Allow"
                Action:
                  - "logs:CreateLogGroup"
                  - "logs:CreateLogStream"
                  - "logs:PutLogEvents"
                  - "logs:DescribeLogStreams"
                Resource: !Sub "arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/*"
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W28 # Resource found with an explicit name, this disallows updates that require replacement of this resource
            reason: "Need explicit name to identify role actions"

  LambdaFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub '${RolePrefix}account-collector-Lambda'
      Description: "Lambda function to retrieve the account list"
      Runtime: python3.8
      Architectures: [arm64]
      Code:
          ZipFile: |
            import os
            import json
            import logging
            import boto3

            ROLE = os.environ['ROLENAME']
            MANAGEMENT_ACCOUNT_IDS = os.environ['MANAGEMENT_ACCOUNT_IDS']

            logger = logging.getLogger(__name__)
            logger.setLevel(getattr(logging, os.environ.get('LOG_LEVEL', 'INFO').upper(), logging.INFO))

            def lambda_handler(event, context):
                logger.info(event)
                try:
                    accounts = main(event["Type"], MANAGEMENT_ACCOUNT_IDS)
                    statusCode = 200
                except Exception as exc:
                    accounts = []
                    statusCode = 500
                    logger.error(f"Exception {exc}")
                    raise exc
                    
                return {
                    'statusCode': statusCode,
                    'accountList': accounts
                }

            def main(type, managementAccounts):
                logger.info(f"Processing for type '{type}'")
                account_list = []
                if (type) == 'MULTI':
                    for account in iterate_accounts(ROLE, managementAccounts):
                        if account['Status'] != 'ACTIVE':
                          logger.info(f"Account {account['Id']} is not active")
                          continue
                        account_data = populate_account(account.get('Id'), account.get('Name'), managementAccounts)
                        account_list.append({"account" : json.dumps(account_data)})

                else:
                    for payer_id in [r.strip() for r in managementAccounts.split(',')]:
                        account_data = populate_account(payer_id, payer_id, payer_id)
                        account_list.append({"account" : json.dumps(account_data)})
                            
                if not account_list:
                    logger.warning("No accounts were collected.")
                    raise RuntimeError("No accounts were collected.")
                
                logger.info(f"Successfully found accounts: {account_list}")
                return account_list

            def populate_account(account_id, account_name, payer_id):
              account_data = {}
              account_data['account_id'] = account_id
              account_data['account_name'] = account_name
              account_data['payer_id'] = payer_id
              return account_data

            def iterate_accounts(role_name, payer_id):
                logging.info("Iterating accounts ...")
                try:
                    creds = assume_role(role_name, payer_id)
                    client = get_client(creds, region="us-east-1", service="organizations") #This MUST be us-east-1 regardless of lambda region
                    for page in client.get_paginator("list_accounts").paginate():
                        for account in page['Accounts']:
                            yield account
                except RuntimeError as exc:
                    raise exc
                except Exception as exc:
                    logger.error(f"Unknown error '{exc}'")
                    raise RuntimeError("Unknown error in 'iterate_accounts'")
                    
            def assume_role(role_name, payer_id):
                logging.info("Assuming role ...")
                try:
                    creds = boto3.client('sts').assume_role(
                        RoleArn=f"arn:aws:iam::{payer_id}:role/{role_name}",
                        RoleSessionName="data_collection"
                    )['Credentials']
                    logging.info(f"Successfully assumed role")
                    return creds
                except Exception as exc:
                    logger.error(f"Error '{exc}' assuming role: role_name={role_name}, payer_id={payer_id}")
                    raise RuntimeError("Error building client")
                
            def get_client(credentials, region, service):
                logging.info("Getting client from credentials ...")
                try:
                    service_client = boto3.client(
                        service,
                        region_name = region,
                        aws_access_key_id=credentials['AccessKeyId'],
                        aws_secret_access_key=credentials['SecretAccessKey'],
                        aws_session_token=credentials['SessionToken'],
                    )
                    logging.info("Successfully got client")
                    return service_client
                except Exception as exc:
                    logger.error(f"Error '{exc}' building client: service={service}, region={region}")
                    raise RuntimeError("Error building client")
      Handler: 'index.lambda_handler'
      MemorySize: 2688
      Timeout: 600
      Role: !GetAtt LambdaRole.Arn
      Environment:
        Variables:
          ROLENAME: !Ref ManagementRoleName
          MANAGEMENT_ACCOUNT_IDS: !Ref ManagementAccountID
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W89 # Lambda functions should be deployed inside a VPC
            reason: "No need for VPC in this case"
          - id: W92 #  Lambda functions should define ReservedConcurrentExecutions to reserve simultaneous executions
            reason: "No need for simultaneous execution"