AWSTemplateFormatVersion: '2010-09-09'
Description: Retrieves AWS Cost Explorer Rightsizing information from across an organization
Parameters:
  DatabaseName:
    Type: String
    Description: Name of the Athena database to be created to hold lambda information
    Default: optimization_data
  DestinationBucket:
    Type: String
    Description: Name of the S3 Bucket that exists or needs to be created to hold rightsizing information
    AllowedPattern: (?=^.{3,63}$)(?!^(\d+\.)+\d+$)(^(([a-z0-9]|[a-z0-9][a-z0-9\-]*[a-z0-9])\.)*([a-z0-9]|[a-z0-9][a-z0-9\-]*[a-z0-9])$)
  DestinationBucketARN:
    Type: String
    Description: ARN of the S3 Bucket that exists or needs to be created to hold rightsizing information
  ManagementRoleName:
    Type: String
    Description: The name of the IAM role that will be deployed in the management account which can retrieve AWS Organization data. KEEP THE SAME AS WHAT IS DEPLOYED INTO MANAGEMENT ACCOUNT
  CFDataName:
    Type: String
    Description: The name of what this cf is doing.
    Default: cost-explorer-rightsizing
  GlueRoleARN:
    Type: String
    Description: Arn for the Glue Crawler role
  Schedule:
    Type: String
    Description: EventBridge Schedule to trigger the data collection
    Default: "rate(14 days)"
  ResourcePrefix:
    Type: String
    Description: This prefix will be placed in front of all roles created. Note you may wish to add a dash at the end to make more readable
  LambdaAnalyticsARN:
    Type: String
    Description: Arn of lambda for Analytics
  AccountCollectorLambdaARN:
    Type: String
    Description: Arn of the Account Collector Lambda
  StepFunctionTemplate:
    Type: String
    Description: JSON representation of common StepFunction template
  StepFunctionExecutionRoleARN:
    Type: String
    Description: Common role for Step Function execution
  SchedulerExecutionRoleARN:
    Type: String
    Description: Common role for module Scheduler execution

Outputs:
  StepFunctionARN:
    Description: ARN for the module's Step Function
    Value: !GetAtt ModuleStepFunction.Arn

Resources:
  LambdaRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub "${ResourcePrefix}${CFDataName}-LambdaRole"
      AssumeRolePolicyDocument:
        Statement:
          - Action:
              - sts:AssumeRole
            Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
        Version: 2012-10-17
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Path: /
      Policies:
        - PolicyName: !Sub "${CFDataName}-ManagementAccount-LambdaRole"
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: "Allow"
                Action: "sts:AssumeRole"
                Resource: !Sub "arn:aws:iam::*:role/${ManagementRoleName}" # Need to assume a Read role in management accounts
        - PolicyName: "S3-Access"
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: "Allow"
                Action:
                  - "s3:PutObject"
                Resource:
                  - !Sub "${DestinationBucketARN}/*"
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W28 # Resource found with an explicit name, this disallows updates that require replacement of this resource
            reason: "Need explicit name to identify role actions"

  LambdaFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub '${ResourcePrefix}${CFDataName}-Lambda'
      Description: !Sub "Lambda function to retrieve ${CFDataName}"
      Runtime: python3.10
      Architectures: [x86_64]
      Code:
        ZipFile: |
          """ Collect RightSizing info from Cost Explorer and Upload to S3
          """
          import os
          import json
          import logging
          from datetime import date, datetime

          import boto3
          import botocore

          class ParamsBase():
              def __init__(self, env, additional_params):
                  logger.setLevel(getattr(logging, env.get('LOG_LEVEL', 'INFO').upper(), logging.INFO))
                  logger.debug("Loading parameters")
                  self.collection_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                  self.tmp_file = "/tmp/tmp.json"
                  self.bucket = env["BUCKET_NAME"]
                  self.role_name = env["ROLE_NAME"]
                  self.module_name = env["MODULE_NAME"]
                  self.regions = [r.strip() for r in env.get("REGIONS","us-east-1").split(',') if r]
                  self.boto_config = None
                  self.additional_params = additional_params

          """
          Custom implementation:
          These functions are specific to this module.
          """
          class Params(ParamsBase):
              """ Tailor this class to add any unique configuration """
              def __init__(self, env, additional_params):
                  try:
                      super().__init__(env, additional_params)
                      self.benefits_considered = True
                      self.targets = {
                          "RightsizingRecommendationsSameFamily": 'SAME_INSTANCE_FAMILY',
                          "RightsizingRecommendationsCrossFamily": 'CROSS_INSTANCE_FAMILY',
                      }
                  except (KeyError, AttributeError) as exc:
                      raise CidCriticalError(f"Invalid parameters supplied", exc)

          def get_api_data(account, params, region):
              """ Method to call the necessary APIs and process the data """
              logger.debug(f"Entering get_api_data for region '{region}'")
              client = get_client_with_role(params.role_name, account.account_id, region="us-east-1", service="ce", params=params) #Must be "us-east-1"
              results = []
              #FIXME: propose a more athena friendly output format
              result = {
                  "RecommendationDate": date.today().strftime('%Y-%m-%d'),
                  "RightsizingRecommendationsSameFamily": [],
                  "RightsizingRecommendationsCrossFamily": [],
              }
              for key, target in params.targets.items():
                  api_params = {
                      'Service': 'AmazonEC2',
                      'Configuration': {
                          'RecommendationTarget': target,
                          'BenefitsConsidered': params.benefits_considered,
                      },
                      'PageSize': 5000,
                  }
                  while True:
                      response = client.get_rightsizing_recommendation(**api_params)
                      result[key] += response["RightsizingRecommendations"]
                      if 'NextPageToken' in response:
                          api_params["NextPageToken"] = response['NextPageToken']
                      else:
                          break
              results.append(result)
              logger.info(f"API results total {len(results)}")
              return results


          def get_s3_key(account, params, region): #pylint: disable=unused-argument
              return datetime.now().strftime(
                  f"{params.module_name}/{params.module_name}-data/payer_id={account.payer_id}/"
                  f"year=%Y/month=%m/day=%d/%Y-%m-%d.json")

          """
          Common implementation:
          These functions and classes are structured for common usage
          patterns across different modules
          """
          logger = logging.getLogger()
          for h in logger.handlers:
              h.setFormatter(logging.Formatter("[%(levelname)s] %(message)s (%(aws_request_id)s)"))
          logger = logging.getLogger(__name__)
          logger.setLevel(logging.INFO)

          def lambda_handler(event, context): #pylint: disable=unused-argument
              """ Common structured entry for Lambda invocation. Core processing done in main()."""
              logger.info(f"Incoming event: {json.dumps(event)}")
              status_code = 500
              try:
                  main(json.loads(event["account"]), event.get('params', ''))
                  status_code = 200
              except KeyError as exc:
                  raise CidCriticalError(f"Account is not defined in the incoming event data. Please do not trigger this function manually. Use the corresponding {os.environ['MODULE_NAME']} state machine in Step Functions instead.")
              except CidNonCriticalError as exc:
                  status_code = 200
              except CidCriticalError as exc:
                  raise exc
              except Exception as exc:
                  raise CidCriticalError(f"(UnhandledExceptionError) in this module", exc)
              finally:
                  return {"statusCode": status_code}

          def main(account_json, additional_params=None):
              """ Method to orchestrate the retrieval and storage of API data """
              logger.debug(f"Entering main")
              try:
                  account = Account(account_json)
                  logger.info(f"Entering main for account: {account.account_id}")
                  params = Params(os.environ, additional_params)
                  for region in params.regions:
                      logger.info(f"Processing for region '{region}'")
                      records = get_api_data(account, params, region)
                      if len(records) > 0:
                          store_to_temp(records, params)
                          upload_to_s3(account, params, region)
                      else:
                          logger.info(f"No file uploaded for region '{region}'")
                  logger.info(f"Exiting main without error")
              except CidError as exc:
                  raise exc
              except (botocore.exceptions.ClientError, ClientAccessError) as exc:
                  raise CidCriticalError(f"Possible role misconfiguration for {params.role_name}", exc)
              except Exception as exc:
                  raise CidCriticalError(f"(UnhandledExceptionError)", exc)

          def store_to_temp(records, params):
              """ Takes the list of processed records and moves them to a temp file """
              logger.debug("Entering store_to_temp")
              count = 0
              try:
                  with open(params.tmp_file, "w", encoding='utf-8') as f:
                      for record in records:
                          f.write(json.dumps(
                              record,
                              default=lambda x: x.isoformat() if isinstance(x, (date, datetime)) else None)
                              + "\n"
                          )
                          count += 1

              except Exception as exc:
                  raise CidCriticalError(f"Unhandled exception in store_to_temp", exc)

              logger.info(f"Stored {count} record(s) in temp file")
              return count

          def upload_to_s3(account, params, region=None):
              """ Moves the processed API data from the temp file to the designated S3 bucket """
              logger.debug(f"Entering upload_to_s3 for bucket {params.bucket}")
              try:
                  key = get_s3_key(account, params, region)
                  boto3.client('s3').upload_file(params.tmp_file, params.bucket, key)
                  logger.info(f"Data stored to s3://{params.bucket}/{key}")
                  return True

              except Exception as exc:
                  raise CidCriticalError("Exception in upload_to_s3", exc)

          def get_client_with_role(role_name, account_id, service, region, params):
              """ Assumes the designated data gathering read-only role and instantiates a boto3 client with it """
              logger.debug(f"Entering get_client_with_role to get '{service}' client with role '{role_name}' from account '{account_id}' in region '{region}'")
              try:
                  credentials = boto3.client('sts').assume_role(
                      RoleArn=f"arn:aws:iam::{account_id}:role/{role_name}",
                      RoleSessionName="data_collection"
                  )['Credentials']
                  logger.debug("Successfully assumed role, now getting client")
                  client = boto3.client(
                      service,
                      region_name = region,
                      aws_access_key_id = credentials['AccessKeyId'],
                      aws_secret_access_key = credentials['SecretAccessKey'],
                      aws_session_token = credentials['SessionToken'],
                      config = params.boto_config
                  )
                  logger.info(f"Successfully created '{service}' client with role '{role_name}' from account '{account_id}' in region '{region}'")
                  return client

              except Exception as exc:
                  raise ClientAccessError(exc, role_name, account_id, service, region)

          # Helper classes
          class Account():
              def __init__(self, account_json: dict):
                  try:
                      self.account_id = account_json["account_id"]
                      self.account_name = account_json["account_name"]
                      self.payer_id = account_json["payer_id"]
                  except KeyError:
                      raise CidCriticalError(f"Invalid account data passed {account_json}")

          class CidError(Exception):
              def __init__(self, message="", exc=None):
                  try:
                      message = f"({type(exc).__name__}) exception. {message}" if exc else message
                      if type(self) == CidNonCriticalError.__class__:
                          logger.warning(message)
                      else:
                          logger.error(message)
                      super().__init__(message)
                  except Exception as exc:
                      pass
          class CidNonCriticalError(CidError):
              def __init__(self, message="", exc=None):
                  super().__init__(message, exc)
          class CidCriticalError(CidError):
              def __init__(self, message="", exc=None):
                  super().__init__(message, exc)
          class ClientAccessError(Exception):
              def __init__(self, exc, role_name, account_id, service, region):
                  message = f"({type(exc).__name__}) exception: '{exc}' when getting '{service}' client with role '{role_name}' from account '{account_id}' in region '{region}'"
                  logger.warning(message)
                  super().__init__(message)
      Handler: 'index.lambda_handler'
      MemorySize: 2688
      Timeout: 600
      Role: !GetAtt LambdaRole.Arn
      Environment:
        Variables:
          LOG_LEVEL: 'INFO'
          BUCKET_NAME: !Ref DestinationBucket
          MODULE_NAME: !Ref CFDataName
          ROLE_NAME: !Ref ManagementRoleName
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W89 # Lambda functions should be deployed inside a VPC
            reason: "No need for VPC in this case"
          - id: W92 #  Lambda functions should define ReservedConcurrentExecutions to reserve simultaneous executions
            reason: "No need for simultaneous execution"

  Crawler:
    Type: AWS::Glue::Crawler
    Properties:
      Name: !Sub '${ResourcePrefix}${CFDataName}-Crawler'
      Role: !Ref GlueRoleARN
      DatabaseName: !Ref DatabaseName
      Targets:
        S3Targets:
          - Path: !Sub "s3://${DestinationBucket}/${CFDataName}/${CFDataName}-data/"

  ModuleStepFunction:
    Type: AWS::StepFunctions::StateMachine
    Properties:
      StateMachineName: !Sub '${ResourcePrefix}${CFDataName}-StateMachine'
      StateMachineType: STANDARD
      RoleArn: !Ref StepFunctionExecutionRoleARN
      DefinitionString: !Ref StepFunctionTemplate
      DefinitionSubstitutions:
        AccountCollectorLambdaARN: !Ref AccountCollectorLambdaARN
        ModuleLambdaARN: !GetAtt LambdaFunction.Arn
        Crawlers: !Sub '["${ResourcePrefix}${CFDataName}-Crawler"]'
        CollectionType: "Payers"
        Params: ''
        Module: !Ref CFDataName
        DeployRegion: !Ref AWS::Region
        Account: !Ref AWS::AccountId
        Prefix: !Ref ResourcePrefix

  ModuleRefreshSchedule:
    Type: 'AWS::Scheduler::Schedule'
    Properties:
      Description: !Sub 'Scheduler for the ODC ${CFDataName} module'
      Name: !Sub '${ResourcePrefix}${CFDataName}-RefreshSchedule'
      ScheduleExpression: !Ref Schedule
      State: ENABLED
      FlexibleTimeWindow:
        Mode: 'OFF'
      Target:
          Arn: !GetAtt ModuleStepFunction.Arn
          RoleArn: !Ref SchedulerExecutionRoleARN

  LambdaAnalyticsExecutor:
    Type: Custom::LambdaAnalyticsExecutor
    Properties:
      ServiceToken: !Ref LambdaAnalyticsARN
      Name: !Ref CFDataName

  AthenaQuerySameFamilyRightSizing:
    Type: AWS::Athena::NamedQuery
    Properties:
      Database: !Ref DatabaseName
      Description: Provides a summary view of the rightsizing recommendations for same family
      Name: cost-explorer-rightsizing-same-family
      QueryString: |
        WITH rightsizing_dates AS (
            SELECT
              "recommendations"."currentinstance"."resourceid"          AS "instance_id"
            , min(date_parse(concat("year", "month", "day"), '%Y%m%d')) AS "earliest_date"
            , max(date_parse(concat("year", "month", "day"), '%Y%m%d')) AS "latest_date"
            , count(*)                                                  AS "frequency"
            FROM (optimization_data.cost_explorer_rightsizing_data
                CROSS JOIN UNNEST("rightsizingrecommendationssamefamily") t(recommendations))
            GROUP BY 1
        ),
        data AS (
            SELECT recommendations
            FROM (optimization_data.cost_explorer_rightsizing_data
                CROSS JOIN UNNEST("rightsizingrecommendationssamefamily") t(recommendations))
            WHERE ("date_parse"("concat"("year", "month", "day"), '%Y%m%d') >= (current_timestamp - INTERVAL '7' DAY))
        ),
        all_tags AS (
            SELECT
              instanceid instance_id
            , exttags.key
            , exttags.value
            FROM inventory_ec2_instances_data
            CROSS JOIN UNNEST(inventory_ec2_instances_data."tags") AS t(exttags)
        ),
        chosen_tags AS (
            SELECT
              instance_id
            , kv['Name'] AS "Name"
            FROM (
                SELECT
                  instance_id
                , map_agg(key, value) AS kv
                FROM all_tags
                GROUP BY instance_id
            )
        ),
        recs AS (
            SELECT "recommendations"."currentinstance"."resourceid"                                          AS "instance_id"
                , "recommendations"."currentinstance"."instancename"                                        AS "instance_name"
                , "recommendations"."accountid"                                                             AS "account_id"
                , "recommendations"."currentinstance"."resourcedetails"."ec2resourcedetails"."instancetype" AS "instance_type"
                , CAST((CASE WHEN (
                    "recommendations"."currentinstance"."resourceutilization"."ec2resourceutilization"."maxcpuutilizationpercentage" =
                    '') THEN null
                              ELSE "recommendations"."currentinstance"."resourceutilization"."ec2resourceutilization"."maxcpuutilizationpercentage"
                        END) AS double)                                                                     AS "max_cpu_utilization"
                , CAST((CASE WHEN (
                    "recommendations"."currentinstance"."resourceutilization"."ec2resourceutilization"."maxmemoryutilizationpercentage" =
                    '') THEN null
                              ELSE "recommendations"."currentinstance"."resourceutilization"."ec2resourceutilization"."maxmemoryutilizationpercentage"
                        END) AS double)                                                                     AS "max_memory_utilization"
                , CAST((CASE WHEN (
                    "recommendations"."currentinstance"."resourceutilization"."ec2resourceutilization"."maxstorageutilizationpercentage" =
                    '') THEN null
                              ELSE "recommendations"."currentinstance"."resourceutilization"."ec2resourceutilization"."maxstorageutilizationpercentage"
                        END) AS double)                                                                     AS "max_disk_utilization"
                , "recommendations"."rightsizingtype"                                                       AS "recommended_action"
                , Try(CASE WHEN ("recommendations"."rightsizingtype" = 'Modify')
                            THEN "recommendations"."modifyrecommendationdetail"."targetinstances"[1]."resourcedetails"."ec2resourcedetails"."instancetype"
                        ELSE ''
                    END)                                                                                     AS "recommended_instance_type_1"
                , CAST("recommendations"."currentinstance"."monthlycost" AS double)                         AS "current_monthly_cost"
                , Try(CASE WHEN ("recommendations"."rightsizingtype" = 'Modify') THEN CAST(
            "recommendations"."modifyrecommendationdetail"."targetinstances"[1]."estimatedmonthlycost" AS double)
                        ELSE 0.0
                    END)                                                                                     AS "estimated_monthly_cost_type_1"
                , Try(CASE WHEN ("recommendations"."rightsizingtype" = 'Modify') THEN CAST(
            "recommendations"."modifyrecommendationdetail"."targetinstances"[1]."estimatedmonthlysavings" AS double)
                        ELSE CAST("recommendations"."currentinstance"."monthlycost" AS double)
                    END)                                                                                     AS "estimated_monthly_savings_type_1"
                  , Try(CASE WHEN ("recommendations"."rightsizingtype" = 'Modify')
                            THEN "recommendations"."modifyrecommendationdetail"."targetinstances"[2]."resourcedetails"."ec2resourcedetails"."instancetype"
                        ELSE ''
                    END)                                                                                     AS "recommended_instance_type_2"
                , CAST("recommendations"."currentinstance"."monthlycost" AS double)                         AS "current_monthly_cost"
                , Try(CASE WHEN ("recommendations"."rightsizingtype" = 'Modify') THEN CAST(
            "recommendations"."modifyrecommendationdetail"."targetinstances"[2]."estimatedmonthlycost" AS double)
                        ELSE 0.0
                    END)                                                                                     AS "estimated_monthly_cost_type_2"
                , Try(CASE WHEN ("recommendations"."rightsizingtype" = 'Modify') THEN CAST(
            "recommendations"."modifyrecommendationdetail"."targetinstances"[2]."estimatedmonthlysavings" AS double)
                        ELSE CAST("recommendations"."currentinstance"."monthlycost" AS double)
                    END)                                                                                     AS "estimated_monthly_savings_type_2"
            , Try(CASE WHEN ("recommendations"."rightsizingtype" = 'Modify')
                            THEN "recommendations"."modifyrecommendationdetail"."targetinstances"[3]."resourcedetails"."ec2resourcedetails"."instancetype"
                        ELSE ''
                    END)                                                                                     AS "recommended_instance_type_3"
                , CAST("recommendations"."currentinstance"."monthlycost" AS double)                         AS "current_monthly_cost"
                , Try(CASE WHEN ("recommendations"."rightsizingtype" = 'Modify') THEN CAST(
            "recommendations"."modifyrecommendationdetail"."targetinstances"[3]."estimatedmonthlycost" AS double)
                        ELSE 0.0
                    END)                                                                                     AS "estimated_monthly_cost_type_3"
                , Try(CASE WHEN ("recommendations"."rightsizingtype" = 'Modify') THEN CAST(
            "recommendations"."modifyrecommendationdetail"."targetinstances"[3]."estimatedmonthlysavings" AS double)
                        ELSE CAST("recommendations"."currentinstance"."monthlycost" AS double)
                    END)                                                                                     AS "estimated_monthly_savings_type_3"
            FROM data
        )
        SELECT
          recs.*
        , rightsizing_dates.earliest_date
        , rightsizing_dates.latest_date
        , rightsizing_dates.frequency
        , chosen_tags.name
        FROM recs
        JOIN rightsizing_dates ON ("rightsizing_dates"."instance_id" = "recs"."instance_id")
        LEFT JOIN chosen_tags ON ("chosen_tags"."instance_id" = "recs"."instance_id")

  AthenaQueryCrossFamilyRightSizing:
    Type: AWS::Athena::NamedQuery
    Properties:
      Database: !Ref DatabaseName
      Description: Provides a summary view of the rightsizing recommendations for cross family
      Name: cost-explorer-rightsizing-cross-family
      QueryString: |
        WITH rightsizing_dates AS (
            SELECT
              "recommendations"."currentinstance"."resourceid"          AS "instance_id"
            , min(date_parse(concat("year", "month", "day"), '%Y%m%d')) AS "earliest_date"
            , max(date_parse(concat("year", "month", "day"), '%Y%m%d')) AS "latest_date"
            , count(*)                                                  AS "frequency"
            FROM (optimization_data.cost_explorer_rightsizing_data
                CROSS JOIN UNNEST("rightsizingrecommendationscrossfamily") t(recommendations))
            GROUP BY 1
        ),
        data AS (
            SELECT recommendations
            FROM (optimization_data.cost_explorer_rightsizing_data
                CROSS JOIN UNNEST("rightsizingrecommendationscrossfamily") t(recommendations))
            WHERE ("date_parse"("concat"("year", "month", "day"), '%Y%m%d') >= (current_timestamp - INTERVAL '7' DAY))
        ),
        all_tags AS (
            SELECT
              instanceid instance_id
            , exttags.key
            , exttags.value
            FROM inventory_ec2_instances_data
            CROSS JOIN UNNEST(inventory_ec2_instances_data."tags") AS t(exttags)
        ),
        chosen_tags AS (
            SELECT
              instance_id
            , kv['Name'] AS "Name"
            FROM (
                SELECT
                  instance_id
                , map_agg(key, value) AS kv
                FROM all_tags
                GROUP BY instance_id
            )
        ),
        recs AS (
            SELECT "recommendations"."currentinstance"."resourceid"                                          AS "instance_id"
                , "recommendations"."currentinstance"."instancename"                                        AS "instance_name"
                , "recommendations"."accountid"                                                             AS "account_id"
                , "recommendations"."currentinstance"."resourcedetails"."ec2resourcedetails"."instancetype" AS "instance_type"
                , CAST((CASE WHEN (
                    "recommendations"."currentinstance"."resourceutilization"."ec2resourceutilization"."maxcpuutilizationpercentage" =
                    '') THEN null
                              ELSE "recommendations"."currentinstance"."resourceutilization"."ec2resourceutilization"."maxcpuutilizationpercentage"
                        END) AS double)                                                                     AS "max_cpu_utilization"
                , CAST((CASE WHEN (
                    "recommendations"."currentinstance"."resourceutilization"."ec2resourceutilization"."maxmemoryutilizationpercentage" =
                    '') THEN null
                              ELSE "recommendations"."currentinstance"."resourceutilization"."ec2resourceutilization"."maxmemoryutilizationpercentage"
                        END) AS double)                                                                     AS "max_memory_utilization"
                , CAST((CASE WHEN (
                    "recommendations"."currentinstance"."resourceutilization"."ec2resourceutilization"."maxstorageutilizationpercentage" =
                    '') THEN null
                              ELSE "recommendations"."currentinstance"."resourceutilization"."ec2resourceutilization"."maxstorageutilizationpercentage"
                        END) AS double)                                                                     AS "max_disk_utilization"
                , "recommendations"."rightsizingtype"                                                       AS "recommended_action"
                                    , Try(CASE WHEN ("recommendations"."rightsizingtype" = 'Modify')
                            THEN "recommendations"."modifyrecommendationdetail"."targetinstances"[1]."resourcedetails"."ec2resourcedetails"."instancetype"
                        ELSE ''
                    END)                                                                                     AS "recommended_instance_type_1"
                , CAST("recommendations"."currentinstance"."monthlycost" AS double)                         AS "current_monthly_cost"
                , Try(CASE WHEN ("recommendations"."rightsizingtype" = 'Modify') THEN CAST(
            "recommendations"."modifyrecommendationdetail"."targetinstances"[1]."estimatedmonthlycost" AS double)
                        ELSE 0.0
                    END)                                                                                     AS "estimated_monthly_cost_type_1"
                , Try(CASE WHEN ("recommendations"."rightsizingtype" = 'Modify') THEN CAST(
            "recommendations"."modifyrecommendationdetail"."targetinstances"[1]."estimatedmonthlysavings" AS double)
                        ELSE CAST("recommendations"."currentinstance"."monthlycost" AS double)
                    END)                                                                                     AS "estimated_monthly_savings_type_1"
                  , Try(CASE WHEN ("recommendations"."rightsizingtype" = 'Modify')
                            THEN "recommendations"."modifyrecommendationdetail"."targetinstances"[2]."resourcedetails"."ec2resourcedetails"."instancetype"
                        ELSE ''
                    END)                                                                                     AS "recommended_instance_type_2"
                , CAST("recommendations"."currentinstance"."monthlycost" AS double)                         AS "current_monthly_cost"
                , Try(CASE WHEN ("recommendations"."rightsizingtype" = 'Modify') THEN CAST(
            "recommendations"."modifyrecommendationdetail"."targetinstances"[2]."estimatedmonthlycost" AS double)
                        ELSE 0.0
                    END)                                                                                     AS "estimated_monthly_cost_type_2"
                , Try(CASE WHEN ("recommendations"."rightsizingtype" = 'Modify') THEN CAST(
            "recommendations"."modifyrecommendationdetail"."targetinstances"[2]."estimatedmonthlysavings" AS double)
                        ELSE CAST("recommendations"."currentinstance"."monthlycost" AS double)
                    END)                                                                                     AS "estimated_monthly_savings_type_2"
            , Try(CASE WHEN ("recommendations"."rightsizingtype" = 'Modify')
                            THEN "recommendations"."modifyrecommendationdetail"."targetinstances"[3]."resourcedetails"."ec2resourcedetails"."instancetype"
                        ELSE ''
                    END)                                                                                     AS "recommended_instance_type_3"
                , CAST("recommendations"."currentinstance"."monthlycost" AS double)                         AS "current_monthly_cost"
                , Try(CASE WHEN ("recommendations"."rightsizingtype" = 'Modify') THEN CAST(
            "recommendations"."modifyrecommendationdetail"."targetinstances"[3]."estimatedmonthlycost" AS double)
                        ELSE 0.0
                    END)                                                                                     AS "estimated_monthly_cost_type_3"
                , Try(CASE WHEN ("recommendations"."rightsizingtype" = 'Modify') THEN CAST(
            "recommendations"."modifyrecommendationdetail"."targetinstances"[3]."estimatedmonthlysavings" AS double)
                        ELSE CAST("recommendations"."currentinstance"."monthlycost" AS double)
                    END)                                                                                     AS "estimated_monthly_savings_type_3"
            FROM data
        )
        SELECT
          recs.*
        , rightsizing_dates.earliest_date
        , rightsizing_dates.latest_date
        , rightsizing_dates.frequency
        , chosen_tags.name
        FROM recs
        JOIN rightsizing_dates ON ("rightsizing_dates"."instance_id" = "recs"."instance_id")
        LEFT JOIN chosen_tags ON ("chosen_tags"."instance_id" = "recs"."instance_id")
